import * as arctic from "arctic"
import { and, eq } from "drizzle-orm"
import { db } from "@/backend/database"
import { accountTable } from "@/backend/database/drizzle/schemas"
import { google } from "./constants"
import { RefreshTokenError, StateOrVerifierError } from "./errors"
import type { AuthAccount, AuthUser, OAuthProvider } from "./types"

const tempStore = new Map<string, string>()

export const GoogleProvider: OAuthProvider = {
	/**
	 * Constructs the URL for calling the Google OAuth2.0
	 * using helper functions from by Articjs.dev
	 */
	getAuthURL() {
		const state = arctic.generateState()
		const codeVerifier = arctic.generateCodeVerifier()
		const scopes = ["openid", "profile", "email"]
		const url = google.createAuthorizationURL(state, codeVerifier, scopes)

		url.searchParams.set("access_type", "offline")

		tempStore.set(state, codeVerifier)
		return url.toString()
	},

	/**
	 * Once logged in, Google sends via searchParams the 'code'
	 * to be exchanged with the 'access_token'.
	 * validateCallback() does the exchange process.
	 *
	 * @param code - Authorization Code to exchange with Google for:
	 * 	- Access Token
	 * 	- ID Token
	 * 	- Refresh Token
	 * @param state - Random string generated by this app
	 * along with 'codeVerifier' sent to Google.
	 * Google stores the 'codeVerifier' and sends back
	 * the 'state' string via searchParams to our app.
	 * App must retrieve 'codeVerifier' (using the 'state')
	 * and send it when exchaning 'code' for tokens.
	 * A layer of protection against CSRF attacks.
	 */
	async validateCallback(code, state) {
		const verifier = tempStore.get(state)

		if (!verifier) throw new StateOrVerifierError("Invalid state or verifier")

		// Exchange 'code' for token
		const tokens = await google.validateAuthorizationCode(code, verifier)

		// Decode id_token to get user basic information
		const claims = arctic.decodeIdToken(tokens.idToken()) as {
			sub: string
			email: string
			name: string
			picture: string
		}

		const user: AuthUser = {
			email: claims.email,
			name: claims.name,
			image: claims.picture
		}

		const account: AuthAccount = {
			provider: "google",
			providerAccountId: claims.sub,
			accessToken: tokens.accessToken(),
			refreshToken: tokens.hasRefreshToken() ? tokens.refreshToken() : undefined,
			expiresAt: Number(tokens.accessTokenExpiresAt()),
			idToken: tokens.idToken(),
			scope: tokens.scopes().toString(),
			tokenType: tokens.tokenType()
		}

		return {
			user,
			account
		}
	},

	/**
	 * Use function in places where really needed
	 * i.e do not use in authMiddleware since it
	 * 		 defeats the purpose of being stateless
	 * 		 (no need of calling db)
	 */
	async refreshAcessToken(session) {
		// Find `refreshToken` from `accounts` table
		// by the userID and provider="google"|"githhub"|...
		const account = await db
			.select({
				refreshToken: accountTable.refresh_token,
				expiresAt: accountTable.expires_at
			})
			.from(accountTable)
			.where(
				and(
					eq(accountTable.userId, session.userId),
					eq(accountTable.provider, session.provider)
				)
			)
			.limit(1)
			.then((arr) => arr[0])

		if (!account.refreshToken || !account.expiresAt)
			throw new RefreshTokenError("Missing Refresh Token or expiration")

		// if provider token still valid then early return
		if (account.expiresAt > Date.now()) return

		// otherwise continue refreshToken process
		const tokens = await google.refreshAccessToken(account.refreshToken)
		if (!tokens) throw new RefreshTokenError("Google could not exchange this token.")

		// Save new tokens to db
		await db
			.update(accountTable)
			.set({
				access_token: tokens.accessToken(),
				expires_at: Number(tokens.accessTokenExpiresAt()),
				refresh_token: tokens.hasRefreshToken()
					? tokens.refreshToken()
					: account.refreshToken
			})
			.where(
				and(
					eq(accountTable.userId, session.userId),
					eq(accountTable.provider, session.provider)
				)
			)
	}
}
