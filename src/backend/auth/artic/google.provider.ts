import * as arctic from "arctic"
import { and, eq } from "drizzle-orm"
import { db } from "@/backend/database"
import { accountTable } from "@/backend/database/drizzle/schemas"
import { google } from "./constants"
import { StateOrVerifierError } from "./errors"
import type { OAuthProvider } from "./types"

const tempStore = new Map<string, string>()

export const GoogleProvider: OAuthProvider = {
	/**
	 * Constructs the URL for calling the Google OAuth2.0
	 * using helper functions from by Articjs.dev
	 */
	getAuthURL() {
		const state = arctic.generateState()
		const codeVerifier = arctic.generateCodeVerifier()
		const scopes = ["openid", "profile", "email"]
		const url = google.createAuthorizationURL(state, codeVerifier, scopes)

		url.searchParams.set("access_type", "offline")

		tempStore.set(state, codeVerifier)
		return url.toString()
	},

	/**
	 * Once logged in, Google sends via searchParams the 'code'
	 * to be exchanged with the 'access_token'.
	 * validateCallback() does the exchange process.
	 *
	 * @param code - Authorization Code to exchange with Google for:
	 * 	- Access Token
	 * 	- ID Token
	 * 	- Refresh Token
	 * @param state - Random string generated by this app
	 * along with 'codeVerifier' sent to Google.
	 * Google stores the 'codeVerifier' and sends back
	 * the 'state' string via searchParams to our app.
	 * App must retrieve 'codeVerifier' (using the 'state')
	 * and send it when exchaning 'code' for tokens.
	 * A layer of protection against CSRF attacks.
	 */
	async validateCallback(code, state) {
		const verifier = tempStore.get(state)

		if (!verifier) throw new StateOrVerifierError("Invalid state or verifier")

		// Exchange 'code' for token
		const tokens = await google.validateAuthorizationCode(code, verifier)

		// Decode id_token to get user basic information
		const claims = arctic.decodeIdToken(tokens.idToken()) as {
			sub: string
			email: string
			name: string
			picture: string
		}

		// TODO: Infer types with Zod + Drizzle
		return {
			email: claims.email,
			name: claims.name,
			picture: claims.picture,
			provider: "google",
			providerAccountId: claims.sub,
			accessToken: tokens.accessToken(),
			refreshToken: tokens.hasRefreshToken() ? tokens.refreshToken() : undefined,
			expiresAt: Number(tokens.accessTokenExpiresAt()),
			idToken: tokens.idToken(),
			scope: tokens.scopes().toString(),
			tokenType: tokens.tokenType()
		}
	},

	async refreshAcessToken(session) {
		try {
			// Find `refreshToken` from `accounts` table
			// by the userID and provider="google"|"githhub"|...
			const { refreshToken } = (
				await db
					.select({
						refreshToken: accountTable.refresh_token
					})
					.from(accountTable)
					.where(
						and(
							eq(accountTable.userId, session.userId),
							eq(accountTable.provider, session.provider)
						)
					)
			)[0]

			if (!refreshToken)
				throw new Error(
					"line 89 - google.provider.ts: There is no refreshToken. Must have one to refresh"
				)

			const tokens = await google.refreshAccessToken(refreshToken)
			const accessToken = tokens.accessToken()
			const accessTokenExpiresAt = tokens.accessTokenExpiresAt()
			const newOrOldRefreshToken = tokens.hasRefreshToken()
				? tokens.refreshToken()
				: refreshToken

			// Save new tokens to db
			await db
				.update(accountTable)
				.set({
					access_token: accessToken,
					expires_at: Number(accessTokenExpiresAt),
					refresh_token: newOrOldRefreshToken
				})
				.where(
					and(
						eq(accountTable.userId, session.userId),
						eq(accountTable.provider, session.provider)
					)
				)

			return {
				accessToken,
				expiresAt: Number(accessTokenExpiresAt),
				refreshToken: newOrOldRefreshToken
			}
		} catch (e) {
			if (e instanceof arctic.OAuth2RequestError) {
				throw new Error(
					"arctic.OAuth2RequestError: Invalid authorization code, credentials, or redirect URI\n",
					e
				)
			}
			if (e instanceof arctic.ArcticFetchError) {
				throw new Error("arctic.ArcticFetchError: Failed to call `fetch()`\n", e)
			}
			// Parse error
			throw new Error(`internal-server-error ${e}`)
		}
	}
}
